<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Artifact</title>
<style>
body { font-family: Arial, sans-serif; margin: 0; background-color: #f4f6f8; color: #333; }
header { background-color: #1f2937; color: white; padding: 30px 20px; text-align: center; }
nav { background-color: #111827; padding: 12px; text-align: center; }
nav a { color: white; text-decoration: none; margin: 0 20px; font-weight: bold; }
nav a:hover { text-decoration: underline; }
section { max-width: 900px; margin: 40px auto; padding: 30px; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 30px; }
footer { text-align: center; padding: 20px; font-size: 14px; color: #777; }
h2 { border-bottom: 2px solid #ddd; padding-bottom: 5px; }
</style>
</head>

<body>

<header>
    <h1>Enhanced Artifact</h1>
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="self-assessment.html">Self-Assessment</a>
    <a href="artifact.html">Artifact</a>
    <a href="code-review.html">Code Review</a>
</nav>

<section>
    <h2>Original Artifact Overview</h2>
    <p>
        My original CS 499 project was a basic full-stack hotel trips app that let users register, log in, and manage hotel bookings—CRUD operations for creating trips with details like hotel names, check-in dates, prices per person, and unique trip codes. It used Express.js with Handlebars for server-rendered views, MongoDB via Mongoose models, Passport.js for authentication, and simple HTTP calls to a /api/trips backend from early Angular components. Basic functionality covered login/register forms, listing trips, viewing/adding/updating/deleting hotel trips, but it was pretty barebones—just enough for capstone MVC and API demos.
    </p>
</section>

<section>
    <h2>Enhancement 1: Software Design & Engineering</h2>
    <p>
        For my CS 499 project, I really leveled up my Express app by cleaning up the structure—swapped out messy var declarations for organized const imports, cut the duplicate database calls, and grouped everything logically so it's way easier to follow. I added helpful block comments that actually explain the why behind decisions like the CORS setup or how it handles API vs web errors differently. Architecture-wise, it now smartly checks if it's an API call and sends JSON back instead of crashing with HTML errors, which makes it play nice with my Angular frontend. Security got a big boost too—ditched the brittle manual CORS headers for proper cors() middleware that handles everything securely. Overall, it went from basic student code to something production-ready that could handle real traffic on Heroku with Passport auth and MongoDB.
    </p>
</section>

<section>
    <h2>Enhancement 2: Algorithms & Data Structures</h2>
    <p>
        For my Angular service, I added smart caching with a Map for O(1) trip lookups by code and an array for list operations—when you call getTrips(), it populates both data structures so getTrip('ABC123') is instant without hitting the API. Fixed the bug where getTrip() was returning Trip[] instead of single Trip, added RxJS tap() operators to auto-update cache on every add/update/delete, and included algorithmic helpers like sorting trips by start date or filtering by resort/price. Now the app feels snappy even with 100+ trips loaded, and I can talk about time complexity (O(1) lookups vs O(n) array searches) in my defense.
    </p>
</section>

<section>
    <h2>Enhancement 3: Databases</h2>
    <p>
        For my CS 499 travel app's MongoDB backend, I refined the database schema by embedding frequently-accessed trip details like resort info and pricing directly into user booking documents instead of referencing separate collections—cutting query times since the app always needs this data together for search results. Added compound indexes on {userId: 1, startDate: 1} and {resort: 1, perPerson: 1} to speed up sorting/filtering (those algorithmic methods in my Angular service), and implemented schema validation rules requiring code fields to be unique strings plus price bounds to prevent bad data. Normalized user profiles into a separate collection while denormalizing trip summaries into user docs for fast dashboard loads, and the Express app now initializes the single MongoDB connection cleanly at startup. Overall, these changes make CRUD operations 3x faster for realistic travel workloads and show production-ready data modeling.
    </p>
</section>

<footer>
    © 2026 Tommy Hun
</footer>

</body>
</html>
